import struct
import hashlib
import sys
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes


IV = b"#GPC0DEMAGICVAL\x00"   # IV exact du malware (16 bytes)


@dataclass
class SystemTime:
    wYear: int
    wMonth: int
    wDayOfWeek: int
    wDay: int
    wHour: int
    wMinute: int
    wSecond: int
    wMilliseconds: int


def parse_header(header: bytes):
    """Retourne (st_header: SystemTime, file_size, stored_hash)."""
    if len(header) < 0x48:
        raise ValueError("Header trop court")

    magic = header[:8]
    tag = header[8:16]
    file_size = struct.unpack("<I", header[16:20])[0]
    reserved = struct.unpack("<I", header[20:24])[0]
    systemtime_raw = struct.unpack("<8H", header[0x18:0x28])
    st = SystemTime(*systemtime_raw)
    stored_hash = header[0x28:0x48]

    if magic != b"GPGcrypt":
        raise ValueError("Magic incorrect")
    if tag != b"_SECRET_":
        raise ValueError("Tag incorrect")

    print("=== HEADER MALWARE ===")
    print("Magic        :", magic, "->", magic.decode(errors="replace"))
    print("Tag          :", tag, "->", tag.decode(errors="replace"))
    print("Taille clair :", file_size)
    print("SYSTEMTIME header : "
          f"{st.wYear}-{st.wMonth:02d}-{st.wDay:02d} "
          f"{st.wHour:02d}:{st.wMinute:02d}:{st.wSecond:02d}.{st.wMilliseconds:03d}")
    print("Hash stocké  :", stored_hash.hex())
    print()

    if reserved != 0:
        print(f"[!] Champ reserved non nul: 0x{reserved:08x}")

    return st, file_size, stored_hash


def systemtime_to_datetime(st: SystemTime) -> datetime:
    """Conversion simple SystemTime -> datetime."""
    return datetime(
        year=st.wYear,
        month=st.wMonth,
        day=st.wDay,
        hour=st.wHour,
        minute=st.wMinute,
        second=st.wSecond,
        microsecond=st.wMilliseconds * 1000,
    )


def build_key_bytes_from_datetime(st_header: SystemTime, dt_key: datetime) -> bytes:
    """
    Construit les 16 octets de clé à partir d’une datetime candidate:
    - année = dt_key.year (année - 6 déjà intégrée)
    - mois, dayOfWeek, day = pris du header (cohérence avec ta logique précédente)
    - heure/min/sec/ms = issus de dt_key
    """
    return struct.pack(
        "<8H",
        dt_key.year,
        st_header.wMonth,
        st_header.wDayOfWeek,
        st_header.wDay,
        dt_key.hour,
        dt_key.minute,
        dt_key.second,
        dt_key.microsecond // 1000,
    )


# ----------------------------
# Vérification rapide de header clair
# ----------------------------

def header_matches_type(prefix: bytes, ext: str) -> bool:
    """
    Vérifie si le début de prefix (bytes déchiffrés) correspond au type de fichier attendu.
    ext doit être en minuscules, avec le point (".jpg", ".pdf", etc.).
    """
    ext = ext.lower()

    # OLE (doc, xls, ppt)
    if ext in (".doc", ".xls", ".ppt"):
        return prefix.startswith(b"\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1")

    # Office Open XML (docx, xlsx, pptx) -> ZIP
    if ext in (".docx", ".xlsx", ".pptx"):
        return prefix.startswith(b"PK\x03\x04") or prefix.startswith(b"PK\x05\x06") or prefix.startswith(b"PK\x07\x08")

    # RTF
    if ext == ".rtf":
        return prefix.startswith(b"{\\rtf")

    # PDF
    if ext == ".pdf":
        return prefix.startswith(b"%PDF")

    # JPEG
    if ext in (".jpg", ".jpeg"):
        return len(prefix) >= 3 and prefix[0:3] == b"\xFF\xD8\xFF"

    # PNG
    if ext == ".png":
        return prefix.startswith(b"\x89PNG\r\n\x1a\n")

    # GIF
    if ext == ".gif":
        return prefix.startswith(b"GIF87a") or prefix.startswith(b"GIF89a")

    # HTML / HTM
    if ext in (".html", ".htm"):
        stripped = prefix.lstrip()
        return stripped.startswith(b"<!DOCT") or stripped.startswith(b"<html") or stripped.startswith(b"<HTML") or stripped.startswith(b"<!")

    # MP4
    if ext == ".mp4":
        return len(prefix) >= 12 and prefix[4:8] == b"ftyp"

    # Si extension inconnue -> on ne sait pas, on retourne False
    return False


# ----------------------------
# Cryptographie
# ----------------------------

def decrypt_prefix_with_key(key_bytes: bytes, ciphertext: bytes, nbytes: int = 64) -> bytes:
    """Déchiffre seulement les nbytes premiers octets avec la clé candidate."""
    cipher = Cipher(algorithms.Camellia(key_bytes), modes.CFB(IV))
    decryptor = cipher.decryptor()
    return decryptor.update(ciphertext[:nbytes])


def decrypt_full_with_key(key_bytes: bytes, ciphertext: bytes, file_size: int) -> bytes:
    """Déchiffre complètement, puis tronque à la taille originale."""
    cipher = Cipher(algorithms.Camellia(key_bytes), modes.CFB(IV))
    decryptor = cipher.decryptor()
    full_plain = decryptor.update(ciphertext) + decryptor.finalize()
    return full_plain[:file_size]


def brute_force_key_with_header(
    st_header: SystemTime,
    ciphertext: bytes,
    file_size: int,
    stored_hash: bytes,
    ext: str,
    max_minutes: int = 10,
):
    """
    Hypothèse :
      SYSTEMTIME_key = SYSTEMTIME_header - 6 ans - delta
      avec 0 <= delta <= max_minutes.

    Pour chaque clé candidate :
      - on déchiffre seulement un petit préfixe,
      - on teste le "magic" du type de fichier,
      - si ça matche, on déchiffre tout + SHA-256 pour confirmer.
    """
    dt_header = systemtime_to_datetime(st_header)
    base_year = st_header.wYear - 6
    dt_base = dt_header.replace(year=base_year)

    print("=== BRUTEFORCE CLÉ (optimisée) ===")
    print("SYSTEMTIME header     :", dt_header)
    print("Base SYSTEMTIME key   :", dt_base, "(année - 6)")
    print(f"Fenêtre de recherche  : 0 à {max_minutes} minutes en arrière")
    print(f"Extension attendue    : {ext}")
    print()

    max_delta_ms = max_minutes * 60 * 1000

    for delta_ms in range(0, max_delta_ms + 1):
        dt_candidate = dt_base - timedelta(milliseconds=delta_ms)
        key_bytes = build_key_bytes_from_datetime(st_header, dt_candidate)

        # Log périodique
        if delta_ms % 60000 == 0:
            minutes = delta_ms // 60000
            print(f"  [*] Test jusqu'à -{minutes} min, clé courante: {key_bytes.hex()}")

        # 1) Déchiffrer un petit préfixe
        prefix = decrypt_prefix_with_key(key_bytes, ciphertext, nbytes=64)

        # 2) Tester le magic selon l'extension
        if not header_matches_type(prefix, ext):
            continue  # clé sûrement mauvaise, on passe à la suivante

        print(f"[+] Magic plausible pour la clé {key_bytes.hex()}, vérification du hash...")

        # 3) Si magic OK, on déchiffre tout + vérifie le hash
        plain = decrypt_full_with_key(key_bytes, ciphertext, file_size)
        calc_hash = hashlib.sha256(plain).digest()

        if calc_hash == stored_hash:
            print("[+] Hash OK, clé valide trouvée :", key_bytes.hex())
            print(f"[+] Trouvée après {delta_ms} ms de recul")
            return key_bytes, plain
        else:
            print("[!] Magic OK mais hash invalide, faux positif sur le header")

    print("[!] Aucune clé trouvée dans la fenêtre de", max_minutes, "minutes")
    return None, None


def decrypt(cipher_path: str, out_path: str, ext_hint: str | None = None, max_minutes: int = 10):
    with open(cipher_path, "rb") as f:
        header = f.read(0x48)
        ciphertext = f.read()

    st_header, file_size, stored_hash = parse_header(header)

    # Déduire l’extension si non donnée
    if ext_hint is None:
        ext_hint = Path(cipher_path).suffix
    if not ext_hint:
        raise ValueError("Impossible de déduire l'extension, fournir ext manuellement.")

    key_bytes, plain = brute_force_key_with_header(
        st_header, ciphertext, file_size, stored_hash, ext_hint, max_minutes=max_minutes
    )

    if plain is None:
        print("[!] Impossible de retrouver le fichier avec cette méthode.")
        return

    print("[+] Écriture du fichier clair :", out_path)
    with open(out_path, "wb") as f:
        f.write(plain)


if __name__ == "__main__":
    if not (3 <= len(sys.argv) <= 4):
        print(f"Usage : {sys.argv[0]} fichier_chiffre sortie_claire [extension]")
        print("  exemple: script.py chiffre.jpeg dechiffre.jpeg .jpeg")
        sys.exit(1)

    cipher_path = sys.argv[1]
    out_path = sys.argv[2]
    ext_hint = sys.argv[3] if len(sys.argv) == 4 else None

    decrypt(cipher_path, out_path, ext_hint)
